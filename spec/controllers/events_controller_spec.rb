require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

RSpec.describe EventsController, type: :controller do
  login_admin


  # This should return the minimal set of attributes required to create a valid
  # Event. As you add validations to Event, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes) {
    FactoryGirl.attributes_for(:event)
  }

  let(:invalid_attributes) {
    {src_ip: nil}
  }

  # This should return the minimal set of values that should be in the session
  # in order to pass any filters (e.g. authentication) defined in
  # EventsController. Be sure to keep this updated too.
  let(:valid_session) { {} }

  describe "GET #index" do
    it "assigns all events as @events" do
      event = Event.create! valid_attributes
      get :index, {}, valid_session
      expect(assigns(:events)).to eq([event])
    end

    describe "#not_done" do
      let!(:first_event)  { FactoryGirl.create(:event, done: false) }
      let!(:second_event) { FactoryGirl.create(:event, done: true) }

      it "get all events" do
        get :index, {all: 1}, valid_session
        expect(assigns(:events)).to contain_exactly(first_event, second_event)
      end

      it "get unprocessed events" do
        get :index, {}, valid_session
        expect(assigns(:events)).to contain_exactly(first_event)
      end
    end

    describe "filtering networks" do
      let!(:first_event)  { FactoryGirl.create(:event, src_ip: "192.0.2.1") }
      let!(:second_event) { FactoryGirl.create(:event, dst_ip: "192.0.2.9") }

      it "search by ip returns first event" do
        get :index, {ip: "192.0.2.1"}, valid_session
        expect(assigns(:events)).to contain_exactly(first_event)
      end

      it "search by /29 mask returns first event" do
        get :index, {ip: "192.0.2.1/29"}, valid_session
        expect(assigns(:events)).to contain_exactly(first_event)
      end

      it "search by /24 mask returns both events" do
        get :index, {ip: "192.0.2.1/24"}, valid_session
        expect(assigns(:events)).to contain_exactly(first_event, second_event)
      end

      it "search by other network empty list" do
        get :index, {ip: "198.51.100.10"}, valid_session
        expect(assigns(:events)).to eq([])
      end
    end

    describe "filtering by event time" do
      let!(:past_event)   { FactoryGirl.create(:event, event_time: (Time.now - 1.month)) }
      let!(:last_event)   { FactoryGirl.create(:event, event_time: (Time.now - 1.day)) }
      let!(:current_event) { FactoryGirl.create(:event, event_time: Time.now) }

      it "get current events" do
        get :index, {since: "today"}, valid_session
        expect(assigns(:events)).to contain_exactly(current_event)
      end

      it "get events since yesterday" do
        get :index, {since: "yesterday"}, valid_session
        expect(assigns(:events)).to contain_exactly(last_event, current_event)
      end
    end

    describe "filter by sensor" do
      let!(:first_event)  { FactoryGirl.create(:event, sensor: "lukcy") }
      let!(:second_event) { FactoryGirl.create(:event, sensor: "luuke") }

      it "search by sensor returns first event" do
        get :index, {sensor: "lukcy"}, valid_session
        expect(assigns(:events)).to contain_exactly(first_event)
      end
    end

    describe "filter by httphost" do
      let!(:first_event)  { FactoryGirl.create(:event, http_hostname: "castor", has_http: true) }
      let!(:second_event) { FactoryGirl.create(:event, http_hostname: "pollux", has_http: false) }

      it "search by httphost returns first event" do
        get :index, {httphost: "castor"}, valid_session
        expect(assigns(:events)).to contain_exactly(first_event)
      end
    end

  end

  describe "GET #show" do
    it "assigns the requested event as @event" do
      event = Event.create! valid_attributes
      get :show, {:id => event.to_param}, valid_session
      expect(assigns(:event)).to eq(event)
    end
  end

  describe "GET #packet" do
    it "downloads a pcap packet" do
      event = Event.create! valid_attributes.
                merge(packet: Base64.encode64("abcde")).
                merge(payload: Base64.encode64("brubbelbrutzelplapperfix"))
      get :packet, {:id => event.to_param}, valid_session
      expect(response.header["Content-Type"]).to eq("Application/vnd.tcpdump.pcap")
      expect(response.header["Content-Disposition"]).to match /event_#{assigns(:event).to_param}.pcap/
      expect(response.header["Content-Disposition"]).to match /attachment/
    end
  end

  describe "GET #edit" do
    it "assigns the requested event as @event" do
      event = Event.create! valid_attributes
      get :edit, {:id => event.to_param}, valid_session
      expect(assigns(:event)).to eq(event)
    end
  end

  describe "PUT #update" do
    context "with valid params" do
      let(:new_attributes) {
        { src_ip: "3.3.3.4" }
      }

      it "updates the requested event" do
        event = Event.create! valid_attributes
        put :update, {:id => event.to_param, :event => new_attributes}, valid_session
        event.reload
        event.src_ip = "3.3.3.4"
      end

      it "assigns the requested event as @event" do
        event = Event.create! valid_attributes
        put :update, {:id => event.to_param, :event => valid_attributes}, valid_session
        expect(assigns(:event)).to eq(event)
      end

      it "redirects to the event" do
        event = Event.create! valid_attributes
        put :update, {:id => event.to_param, :event => valid_attributes}, valid_session
        expect(response).to redirect_to(event)
      end
    end

    context "with invalid params" do
      it "assigns the event as @event" do
        event = Event.create! valid_attributes
        put :update, {:id => event.to_param, :event => invalid_attributes}, valid_session
        expect(assigns(:event)).to eq(event)
      end

      it "re-renders the 'edit' template" do
        event = Event.create! valid_attributes
        put :update, {:id => event.to_param, :event => invalid_attributes}, valid_session
        expect(response).to render_template("edit")
      end
    end
  end

  describe "DELETE #destroy" do
    it "destroys the requested event" do
      event = Event.create! valid_attributes
      expect {
        delete :destroy, {:id => event.to_param}, valid_session
      }.to change(Event, :count).by(-1)
    end

    it "redirects to the events list" do
      event = Event.create! valid_attributes
      delete :destroy, {:id => event.to_param}, valid_session
      expect(response).to redirect_to(events_url)
    end
  end

end
